(lambda **lib: (globals().update(lib), logging.basicConfig(level=logging.INFO, format="%(message)s"), (lambda Matrix, LPol: (lambda Eq: (lambda eq: (eq.normalize(), print(f'Ответ:\n{chr(10).join(eq.solve())}')))(Eq(*map(lambda x: input(), range(int(input('Кол-во уравнений: ')))))))(type('Eq', (object,), {'__init__': lambda self, *eqs: (None, setattr(self, 'eqs', list()), setattr(self, 'vars', None), tuple(map(lambda eq: (lambda match: (lambda left, right: (lambda terms: self.eqs.append(dict(map(lambda x: (x[1], prs_coef(x[0])), terms)) | {'=': int(right)}) if terms else raise_('переменные не найденны'))(re.findall(r'([+-]?\d*)([a-z][a-z0-9_]*)', left)))(*match.groups()) if match else raise_('неправильно, попробуй еще раз'))(re.match(r'(.*)=([+-]?\d+)', eq.replace(' ', ''))), eqs)))[0], 'normalize': lambda self: (lambda vrs: (None, setattr(self, 'vars', vrs), setattr(self, 'eqs', tuple(map(lambda eq: dict.fromkeys(vrs, 0) | eq, self.eqs))))[0])(tuple(sorted(filter(lambda x: x != '=', set().union(*self.eqs))))), 'get_matrix': lambda self: (lambda m: (setattr(m, 'mem', list(itertools.chain.from_iterable(map(lambda x: x.values(), self.eqs)))), m)[-1])(Matrix(len(self.eqs), len(self.vars) + 1)) if self.vars is not None else raise_(f'The system must be normalized (.normolize) first!'), 'solve': lambda self: (lambda A: (logging.info(f"Матрица:\n{A}"), logging.info("--Приведение матрицы--"), (lambda R_cols, Y: (logging.info(f'Приведенная матрица:\n{A}'), logging.info(f'Матрица преобразования столбцов:\n{R_cols}'), (lambda k: tuple(map(lambda i: Y.__setitem__((i + 1, 1), LPol({f't{i - k}': 1})) if i + 1 <= A.n and A[i + 1, A.m] == 0 or i + 1 > A.n else raise_(f'{A[i + 1, A.m]} != 0, решений нет'), range(k, A.m - 1))))(next(filter(lambda i: not (A[i + 1, i + 1] != 0 and (True, Y.__setitem__((i + 1, 1), LPol({'': A[i + 1, A.m] // A[i + 1, i + 1]})) if A[i + 1, A.m] % A[i + 1, i + 1] == 0 else raise_(f'{A[i + 1, A.m]} не делит {A[i + 1, i + 1]}, решений нет'))[0]), range(min(A.n, A.m - 1))), min(A.n, A.m - 1))), logging.info(f'Столбец со свободными переменными:\n{Y}'), (lambda solution: (logging.info(f'Результат (обратная замена переменных):\n{solution}'), tuple(map(lambda var, pol: f'{var} = {str(pol)}', self.vars, solution.mem)))[-1])(R_cols * Y))[-1])(A.smith_form(A.n, A.m - 1), Matrix(A.m - 1, 1)))[-1])(self.get_matrix()) if self.vars is not None else raise_(f'The system must be normalized (.normolize) first!')})))(type('Matrix', (object,), {'__init__': lambda self, n, m: (None, setattr(self, 'n', n), setattr(self, 'm', m), setattr(self, 'mem', [0] * n * m))[0], '__getitem__': lambda self, index: self.mem[(index[0] - 1) * self.m + (index[1] - 1)], '__setitem__': lambda self, index, value: self.mem.__setitem__((index[0] - 1) * self.m + (index[1] - 1), value), 'get_col': lambda self, index: self.mem[index - 1::self.m], 'get_row': lambda self, index: self.mem[(index - 1) * self.m:index * self.m], '__str__': lambda self: '\n'.join((lambda m: map(lambda i: '|' + '|'.join(map(lambda x: format(str(x), f'^{m}'), self.get_row(i + 1))) + '|', range(self.n)))(max(map(lambda x: len(str(x)), self.mem)))), '__add__': lambda self, other: (lambda result: (tuple(map(lambda x: result.mem.__setitem__(x[0] * self.m + x[1], self.mem[x[0] * self.m + x[1]] + other.mem[x[0] * self.m + x[1]]), itertools.product(range(self.n), range(self.m)))), result)[-1])(self.__class__(self.n, self.m)) if self.n != other.n or self.m != other.m else raise_("Matrices must have the same dimensions for addition."), '__mul__': lambda self, other: (lambda m: (m.__setattr__('mem', list(map(lambda x: x * other, self.mem))), m)[-1])(self.__class__(self.n, self.m)) if isinstance(other, (int, float)) else ((lambda m: (m.__setattr__('mem', list(map(lambda x: (lambda i, j: functools.reduce(lambda acc, x: acc + x[0] * x[1], zip(self.get_row(i + 1), other.get_col(j + 1)), 0))(*divmod(x, other.m)), range(self.n * other.m)))), m)[-1])(self.__class__(self.n, other.m)) if self.m == other.n else raise_("The number of columns in the first matrix must equal the number of rows in the second matrix.")) if isinstance(other, self.__class__) else raise_("Unsupported operand type(s) for *: 'Matrix' and '{}'".format(type(other).__name__)), '__rmul__': lambda self, other: self.__mul__(other), 'row_add': lambda self, i, j, k: (None, tuple(map(lambda col: self.__setitem__((i, col + 1), self[j, col + 1] * k + self[i, col + 1]), range(self.m))))[0], 'row_swap': lambda self, i, j: (None, tuple(map(lambda col: (lambda t: (self.__setitem__((i, col + 1), self[j, col + 1]), self.__setitem__((j, col + 1), t)))(self[i, col + 1]), range(self.m))))[0], 'row_scale': lambda self, i, k: (None, tuple(map(lambda col: self.__setitem__((i, col + 1), self[i, col + 1] * k), range(self.m))))[0], 'col_add': lambda self, i, j, k: (None, tuple(map(lambda row: self.__setitem__((row + 1, i), self[row + 1, j] * k + self[row + 1, i]), range(self.n))))[0], 'col_swap': lambda self, i, j: (None, tuple(map(lambda row: (lambda t: (self.__setitem__((row + 1, i), self[row + 1, j]), self.__setitem__((row + 1, j), t)))(self[row + 1, i]), range(self.n))))[0], 'col_scale': lambda self, i, k: (None, tuple(map(lambda row: self.__setitem__((row + 1, i), self[row + 1, i] * k), range(self.n))))[0], 'smith_form': lambda self, max_rows, max_cols: (lambda R: (tuple(map(lambda i: R.__setitem__((i + 1, i + 1), 1), range(max_cols))), tuple(map(lambda i: (lambda pivot: (None, logging.info(f'Опорный элемент: {pivot}'), logging.info('-Преобразование строк-'), (lambda frame: tuple(iter(lambda: (lambda curent: (True, logging.info(log_tab(f'Смена опорного элемента на {curent}', 1)), frame.f_locals.__setitem__('pivot', curent), ctypes.pythonapi.PyFrame_LocalsToFast(ctypes.py_object(frame)))[0] if curent is not None else False)(next(filter(lambda curent: (logging.info(log_tab(f'Матрица:\n{log_tab(str(self), 1)}\nЭлемен: {curent}', 1)), self.row_add(curent[0], pivot[0], -(self[*curent] // self[*pivot])), self[*curent] != 0)[-1], map(lambda j: ((pivot[0] + j - i) % (max_rows - i) + i + 1, pivot[1]), range(max_rows - i - 1))), None)), False)))(inspect.currentframe()), logging.info('-Преобразование столбцов-'), (lambda frame: (tuple(iter(lambda: (lambda curent: (True, logging.info(log_tab(f'Смена опорного элемента на {curent}', 1)), frame.f_locals.__setitem__('pivot', curent), ctypes.pythonapi.PyFrame_LocalsToFast(ctypes.py_object(frame)))[0] if curent is not None else False)(next(filter(lambda curent: (logging.info(log_tab(f'Матрица:\n{log_tab(str(self), 1)}\nЭлемен: {curent}', 1)), (lambda k: (self.col_add(curent[1], pivot[1], -k), R.col_add(curent[1], pivot[1], -k)))(self[*curent] // self[*pivot]), self[*curent] != 0)[-1], map(lambda j: (pivot[0], (pivot[1] + j - i) % (max_cols - i) + i + 1), range(max_cols - i - 1))), None)), False))))(inspect.currentframe()), logging.info(f'Матрица:\n{self}'), logging.info('Ставим опорный элемент на главную диагональ:'), self.row_swap(pivot[0], i + 1), self.col_swap(pivot[1], i + 1), R.col_swap(pivot[1], i + 1), logging.info(f'{self}'))[0] if pivot is not None else None)(min(filter(lambda x: self[*x] != 0, itertools.chain(map(lambda x: (x + 1, i + 1), range(i, max_rows)), map(lambda x: (i + 1, x + 1), range(i, max_cols)))), key=lambda x: self[*x], default=None)), range(min(max_rows, max_cols)))), R)[-1])(self.__class__(max_cols, max_cols))}), type('LPol', (object,), {'__init__': lambda self, cof: (None, setattr(self, 'cof', cof), self.cof.__setitem__('', self.cof.get('', 0)))[0], '__add__': lambda self, other: self.__class__({int: lambda new: (new.__setitem__('', new.get('', 0) + other), new)[-1], self.__class__: lambda new: (*map(lambda x: new.__setitem__(x[0], new.get(x[0], 0) + x[1]), other.cof.items()), new)[-1]}.get(type(other), lambda new: raise_(f'TypeError, other must be int or {self.__class__}'))(self.cof.copy())), '__radd__': lambda self, other: self.__add__(other), '__mul__': lambda self, scalar: self.__class__(dict(map(lambda x: (x[0], x[1] * scalar), self.cof.items()))), '__rmul__': lambda self, scalar: self.__mul__(scalar), '__str__': lambda self: " + ".join((lambda x: (str(x),) if x != 0 else ('0',) if all(map(lambda x: x == 0, self.cof.values())) else ())(self.cof.get('', 0)) + tuple(map(lambda x: f"{({1: '', -1: '-'}.get(x[1], x[1]))}{x[0]}", sorted(filter(lambda x: x[0] != '' and x[1] != 0, self.cof.items()))))).replace(" + -", " - ")})))[-1])(functools=__import__('functools'), logging=__import__('logging'), itertools=__import__('itertools'), inspect=__import__('inspect'), ctypes=__import__('ctypes'), raise_=lambda s: __import__('ctypes').pythonapi.Py_FatalError(s.encode('utf-8')), re=__import__('re'), prs_coef=lambda coef: ({'+': lambda c: 1, '-': lambda c: -1, '': lambda c: 1}.get(coef, lambda c: int(c)))(coef), log_tab=lambda log, n: f'\n'.join(map(lambda line: "\t" * n + line, log.split('\n'))))